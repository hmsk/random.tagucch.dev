---
title: 'const n=1 と const n:1=1 は何が違うのか、なぜ違うのかを読んだ'
tags: ['TypeScript']
---

## const n=1 と const n:1=1 は何が違うのか、なぜ違うのかを読んだ

[TypeScript: const n=1とconst n:1=1は何が違うのか、なぜ違うのか](https://zenn.dev/luma/articles/typescript-const-n-1)

読んだ。

`const n:1 = 1` と `const n = 1` はどう違うかは、最初に「1 型と number 型かな」と思った。実際の挙動的にはそういう感じっぽいけど。

Type Narrowing という仕組み自体は初めて知った。

[TypeScript: Documentation \- Narrowing](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)

> すべての変数は、その変数の型とは別に、Type Narrowingという仕組みによって一時的に別の型として取り扱う機能があります。

記事にあるとおり、条件分岐で型が限定的になることが分かる部分では TypeScript 側でちゃんと別の型として認識してくれる。頭いいな〜。

> TypeScriptに限らず、ある程度の型推論を行う言語において、型は詳しければ詳しいほど良いとは限りません。例えば、次の例では number[] に推論されるのを期待していますが、実際には 1[] になってしまい、1以外の数値がpushできません。

ここの部分を見てなるほどな……と思った。型は詳しければ詳しいほどよくない？と思っていたのだけど、実際はそうしてしまうと値の変更など(配列の要素追加など)がうまくできない場合があるんだなあというのを知った。

共変性と反変性に関しては昔ちょっとだけ聞いたな〜くらいのものなので、詳しく知ったほうがいい気がする。

[共変性と反変性 \(計算機科学\) \- Wikipedia](https://ja.wikipedia.org/wiki/%E5%85%B1%E5%A4%89%E6%80%A7%E3%81%A8%E5%8F%8D%E5%A4%89%E6%80%A7_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%A6))

> 反変が起こり得るため、「推論される型はより詳細なほうがいいとは限らない」ことがわかりました。

記事内の defaultPage の例がわかりやすかった。

また、スコープが同じか下位かで推論が変わり、同じスコープだとより厳密に推論され、下位のスコープだと反変性を考慮して推論されるというのも勉強になった。そして const ではなく let を使うと、下位のスコープに厳密な推論が引き継がれるらしい。なるほどな〜。

> 最後にどちらを使ったほうが良いかという話ですが、場合によりけりです。const構文を使う理由がconstantという意味であれば1と書いたほうが良いでしょうし、immutableという意味であれば上記の例のdefaultPageのようにnumberにするのが良いと思います。

勉強になりました。
